import spacy, pickle
import sys
from spacy.parts_of_speech import NOUN
from spacy.parts_of_speech import ADJ
from spacy.parts_of_speech import VERB
from spacy.parts_of_speech import PRON
from spacy.parts_of_speech import CONJ
from spacy.parts_of_speech import INTJ
from spacy.parts_of_speech import PUNCT
from spacy.parts_of_speech import NUM
from spacy.parts_of_speech import SYM

with open('sindarinDictionary.pickle', 'rb') as handle:
  elvishDict = pickle.load(handle) 

#gets parts of speech from SpaCy
def is_noun(token):
    return token.pos == spacy.parts_of_speech.NOUN
def is_adjective(token):
    return token.pos == spacy.parts_of_speech.ADJ
def is_verb(token): 
    return token.pos == spacy.parts_of_speech.VERB
def is_adverb(token):
    return token.pos == spacy.parts_of_speech.ADV
def is_pronoun(token):
    return token.pos == spacy.parts_of_speech.PRON
def is_properNoun(token):
    return token.pos == spacy.parts_of_speech.PROPN
def is_conjunction(token):
    return token.pos == spacy.parts_of_speech.CONJ
def is_interjection(token):
    return token.pos == spacy.parts_of_speech.INTJ
def is_punctuation(token):
    return token.pos == spacy.parts_of_speech.PUNCT
def is_number(token):
    return token.pos == spacy.parts_of_speech.NUM
def is_symbol(token):
    return token.pos == spacy.parts_of_speech.SYM
def is_preposition(token):
    return token.pos == spacy.parts_of_speech.ADP
def is_determiner(token):
    return token.pos == spacy.parts_of_speech.DET

#Sets the POS to the correct pos key in the Sindarin Dictionary
def determinePOS (token):
    if is_noun(token):
        POS = 'n.'
        return POS
    if is_adjective(token):
        POS = 'adj.'
        return POS
    if is_preposition(token):
        POS = 'prep.'
        return POS
    if is_verb(token):
        POS = 'v.'
        return POS
    if is_determiner(token):
        POS = 'det.'
        return POS
    if is_adverb(token):
        POS = 'adv.'
        return POS
    if is_pronoun(token):
        POS = 'pron.'
        return POS
    if is_properNoun(token):
        POS = 'propn.'
        return POS
    if is_conjunction(token):
        POS = 'conj.'
        return POS
    if is_interjection(token):
        POS = 'interj.'
        return POS
    if is_punctuation(token):
        POS = 'punct.'
        return POS
    if is_number(token):
        POS = 'num'
        return POS
    if is_symbol(token):
        POS = 'sym'
        return POS

#used to turn error checking on and off
errorPrint = 0

#finds the root of a sentence.    
def find_root(docu): 
    for token in docu:
        if token.head is token:
            return token

#Counts the number of children a token has        
def countChildren(children):
    count = 0
    for i in children:
        count = count + 1
    return count

def printTree(token):
    children = token.children
    for i in children:
        print('\t\t', i)
        
#finds the Elvish word in the Sindarin Dicitonary
def findElvish(token, speech):
    if(speech != 'propn.'):
        node = token.lower_

    elif(speech == 'propn.'):
        node = token.text
        
    if node in elvishDict:
        if speech in elvishDict[node]:
            return elvishDict[node][speech][0] + ''
        else:
            return node + '*'
    else:
        return node + '*'

#Problems with ordinal numbers
#walks the tree generated by SpaCy and returns the output sentence
def walkTree(token, output, holder):
    testString = ''
    if(errorPrint == 1):
        print('Token: ' + token.text)
    speech = determinePOS(token)
    children = []
    children = token.children
    if(errorPrint == 1):
        print('\tChildren for ' , token, ' ', speech, ' ', token.ent_type_, ' ', token.lemma_, ' ', token.pos_, ' ', token.tag_, ' :')
        printTree(token)
    childrenBackup = token.children
    childCount = countChildren(childrenBackup)
    if(errorPrint == 1):
        print('\tChild Count: ', childCount)
    vPrint = 0
    v2Print = 0
    
    if (speech == 'v.'):
        if(errorPrint == 1):
            print('\t\tverb check')
        if (childCount == 0):
                if(errorPrint == 1):
                    print('\t\t no child check')
                return findElvish(token, speech)
    
        for child in children:
            childSpeech = determinePOS(child)

            if(childCount < 3 and vPrint == 0 and v2Print == 0):
                if(errorPrint == 1):
                    print('\t\tverb at Start check.')
                output += findElvish(token, speech)
                output += walkTree(child, '', holder)
                vPrint += 1
                v2Print += 1
                if(errorPrint == 1):
                    print('\t\t', output)

            elif ((childSpeech == 'n.' or childSpeech == 'pron.' or childSpeech == 'propn.' or childSpeech == 'adv.' or childSpeech == 'det.' or childSpeech == 'v.' ) and vPrint == 0):
                if(errorPrint == 1):
                    print('\t\tvPrint')
                vPrint += 1
                output += walkTree(child, '', holder)
                if(v2Print == 0):
                    v2Print += 1
                    output +=  ' ' + findElvish(token, speech)
                if(errorPrint == 1):
                    print('\t\t',output)

            elif((childSpeech == 'prep.' or childSpeech == 'adv.' or childSpeech == 'pron.' or childSpeech == 'n.') and vPrint == 1):
                if(errorPrint == 1):
                    print('\t\tprint verb check: ', child)
                output += walkTree(child, '', holder)
                if(errorPrint == 1):
                    print('\t\t',output)

            elif (childSpeech == 'punct.'):
                output += walkTree(child, '', holder)
                
            else: 
                output += ' ' + walkTree(child, '', holder)
                if(errorPrint == 1):
                    print('\t\tV loop check: ' , output)
            
        if(errorPrint == 1):
            print('\t\tVoutput check: ' , output)
        return output

    elif(speech  == 'punct.'):
        if(errorPrint == 1):
            print('\t\tpunct check')
        return token.text

    elif(speech == 'prep.'):
        if(errorPrint == 1):
            print('\t\tprep check')
        output += ' ' + findElvish(token, speech)
        if(errorPrint == 1):
            print('\t\tprep output check: ' , output)
        for child in children:
            output += ' ' + walkTree(child, '', holder)
        return output

    elif(speech == 'det.'):
        if(errorPrint == 1):
            print('\t\tdet check')
        return findElvish(token, speech)

    elif(speech == 'conj.'): 
        if(errorPrint == 1):
            print('\t\tConjunction check')
        return findElvish(token, speech)

    elif(speech == 'num.'):  # in token.ent.type_  has ORDINAL(first) and CARDNIAL(one)
        if(errorPrint == 1):
            print('\t\tNumber check')
        return findElvish(token, speech)

    elif(speech == 'adj.'): 
        if(errorPrint == 1):
            print('\t\tAdjective check')
        output += ' ' + findElvish(token, speech)
        if(errorPrint == 1):
            print('\t\tAdjective output check: ' , output)
        for child in children:
            output += ' ' + walkTree(child, '', holder)
        return output
        
    elif (speech == 'pron.'):
        if(errorPrint == 1):
            print('\t\tPronoun check')
        return findElvish(token, speech)
    
    elif (speech == 'propn.'):
        if(errorPrint == 1):
            print('\t\tProper noun check')
        return findElvish(token, speech)
    
    elif (speech == 'adv.'):
        if(errorPrint == 1):
            print('\t\tAdverb check')
        output += ' ' + findElvish(token, speech)
        if(errorPrint == 1):
            print('\t\tAdverb output check: ' , output)
        for child in children:
            output += ' ' + walkTree(child, '', holder)
        return output

    elif(speech == 'n.'):
        if(errorPrint == 1):
            print('\t\tnoun check')
        nPrint = 0
        
        for child in children:
            childSpeech = determinePOS(child)
                
            if (childSpeech == 'adj.' and nPrint == 0):
                if(errorPrint == 1):
                    print('\t\tadj noun print check: ', output)
                nPrint += 1
                output +=  ' ' + findElvish(token, speech)
                
            if ( childSpeech == 'conj.' and nPrint == 0): 
                if(errorPrint == 1):
                    print('\t\tconj noun print check: ', output)
                nPrint += 1
                output += ' ' + findElvish(token, speech) + ' ' + walkTree(child, '', holder)
                
            else :
                output += ' ' + walkTree(child, '', holder)
                
        if(nPrint  == 0 and childCount < 2):
            output += ' ' + findElvish(token, speech)
            
        if(errorPrint == 1):
            print('\t\tnoun output check', token.text , ': ' , output, )
        return output
        
#################################
en_nlp = spacy.load('en')
running = 1
print('Welcome to the Sindarin Tranlator!')
print('If you wish to stop this program, input "stopProgram".')
print('To turn on Error checking type "errorCheck", to turn Error checking off type "noErrorCheck".')
print('Spelling and puncuation matters!')
while(running != 0):     
    userInput = input('Enter a word/sentence to translate: ')
    en_doc = en_nlp(userInput)
    
    sentences = list(en_doc.sents)
    children = []
    for sentence in sentences:
        sent = ''
        holder = ''
        output = ''
        root = find_root(sentence)
        
        if(root.text == 'stopProgram'):
            running = 0
            print('Novaer mellon!') #"Farewel friend!"
        elif(root.text == 'errorCheck'):
            errorPrint = 1
            print('Output will now display error checking!\n')
        elif(root.text == 'noErrorCheck'):
            errorPrint = 0
            print('Output will now only display the translation!\n')
            
        else:
            print('Translation: ', walkTree(root, sent, holder), '\n')
        
